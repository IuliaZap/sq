#include <QCoreApplication>
#include <QAudioInput>
#include <QIODevice>
#include <QFile>
#include <QByteArray>
#include <QDebug>
#include <QTextStream> //#
#include <iostream> //#
using namespace std; //#
#include <QVector>//#
#include <qendian.h>

QAudioInput* audio;
QAudioFormat format_test;
QAudioFormat format;
QIODevice *input;
QFile file("out.txt");
QTextStream text_out(&file); //#

// параметры фильтра1 5200Гц
const QVector<float> coeff_buf1 =   {
    0.0001223077998f,0.0003212716547f,0.0002211412939f,-3.52360621e-05f,-0.0001801491017f,
    1.761533349e-05f,0.0001855564915f,1.862973113e-05f,-0.0002115379175f,-6.480750017e-05f,
    0.0002318563929f,0.0001275309332f,-0.0002426030405f,-0.0002027368464f,0.0002367390116f,
    0.0002879940439f,-0.0002099739359f,-0.000378635712f,0.0001583035773f,0.0004690969654f,
    -7.899478805e-05f,-0.0005525139859f,-2.920626684e-05f,0.0006212408189f,0.0001658407709f,
    -0.0006669674767f,-0.000328328344f,0.0006813500659f, 0.000511923281f,-0.0006564365467f,
    -0.0007095625624f,0.0005853045732f,0.0009119354654f,-0.0004626391747f,-0.001107754651f,
    0.0002853082842f, 0.001284090686f,-5.294919538e-05f,-0.001426957548f,-0.0002315903112f,
     0.001521934057f,0.0005619520671f,-0.001554950606f,-0.0009281134699f,  0.00151323271f,
     0.001316450187f,-0.001386163873f,-0.001709946198f, 0.001166231348f, 0.002088745357f,
    -0.0008498533862f,-0.002430909313f,0.0004381401814f, 0.002713265596f, 6.25585817e-05f,
    -0.002912638476f,-0.0006404390442f, 0.003007010324f, 0.001278062933f,-0.002976920689f,
    -0.001952727907f, 0.002806699602f, 0.002637000522f, -0.00248576724f,-0.003299606498f,
     0.002009816235f, 0.003906600643f,-0.001381600159f,-0.004422800615f,0.0006116140867f,
     0.004813433159f,0.0002813871251f, -0.00504624052f,  -0.0012712233f, 0.005092375446f,
     0.002323277993f,-0.004930454772f, -0.00339841214f, 0.004544706549f, 0.004450864159f,
    -0.003929368686f,-0.005432073027f, 0.003088800702f, 0.006292500068f,-0.002037831815f,
    -0.006983601488f,0.0008021576796f, 0.007460333873f,0.0005819774815f,-0.007683433592f,
    -0.002068632981f, 0.007621866185f, 0.003603594145f,-0.007255009376f,-0.005126486067f,
     0.006573955994f, 0.006572874729f,-0.005583165679f,-0.007877226919f, 0.004300828557f,
     0.008975577541f,-0.002759079682f,-0.009808764793f, 0.001003369456f,  0.01032529026f,
    0.0009088460938f, -0.01048410032f,-0.002909975359f,  0.01025709044f, 0.004924757406f,
    -0.009630927816f,-0.006873290055f, 0.008608528413f, 0.008674254641f, -0.00720967073f,
     -0.01024852507f, 0.005470851902f,  0.01152275689f,-0.003444566391f, -0.01243282389f,
     0.001197505742f,  0.01292704884f, 0.001191688702f, -0.01296892017f,-0.003635409987f,
      0.01253923308f, 0.006040658802f, -0.01163752936f,-0.008312736638f,  0.01028270274f,
      0.01035946794f,-0.008512804285f, -0.01209506486f, 0.006383897737f,  0.01344411261f,
    -0.003968172707f, -0.01434502192f, 0.001351192128f,  0.01475293748f, 0.001371459919f,
     -0.01464208122f,-0.004098029342f,  0.01400712412f, 0.006724928506f, -0.01286370028f,
    -0.009150815196f,   0.0112482924f,  0.01128138788f, -0.00921645388f, -0.01303276233f,
     0.006841447204f,  0.01433594525f,-0.004210411105f, -0.01513926312f,  0.00142128882f,
       0.0154106319f,  0.00142128882f, -0.01513926312f,-0.004210411105f,  0.01433594525f,
     0.006841447204f, -0.01303276233f, -0.00921645388f,  0.01128138788f,   0.0112482924f,
    -0.009150815196f, -0.01286370028f, 0.006724928506f,  0.01400712412f,-0.004098029342f,
     -0.01464208122f, 0.001371459919f,  0.01475293748f, 0.001351192128f, -0.01434502192f,
    -0.003968172707f,  0.01344411261f, 0.006383897737f, -0.01209506486f,-0.008512804285f,
      0.01035946794f,  0.01028270274f,-0.008312736638f, -0.01163752936f, 0.006040658802f,
      0.01253923308f,-0.003635409987f, -0.01296892017f, 0.001191688702f,  0.01292704884f,
     0.001197505742f, -0.01243282389f,-0.003444566391f,  0.01152275689f, 0.005470851902f,
     -0.01024852507f, -0.00720967073f, 0.008674254641f, 0.008608528413f,-0.006873290055f,
    -0.009630927816f, 0.004924757406f,  0.01025709044f,-0.002909975359f, -0.01048410032f,
    0.0009088460938f,  0.01032529026f, 0.001003369456f,-0.009808764793f,-0.002759079682f,
     0.008975577541f, 0.004300828557f,-0.007877226919f,-0.005583165679f, 0.006572874729f,
     0.006573955994f,-0.005126486067f,-0.007255009376f, 0.003603594145f, 0.007621866185f,
    -0.002068632981f,-0.007683433592f,0.0005819774815f, 0.007460333873f,0.0008021576796f,
    -0.006983601488f,-0.002037831815f, 0.006292500068f, 0.003088800702f,-0.005432073027f,
    -0.003929368686f, 0.004450864159f, 0.004544706549f, -0.00339841214f,-0.004930454772f,
     0.002323277993f, 0.005092375446f,  -0.0012712233f, -0.00504624052f,0.0002813871251f,
     0.004813433159f,0.0006116140867f,-0.004422800615f,-0.001381600159f, 0.003906600643f,
     0.002009816235f,-0.003299606498f, -0.00248576724f, 0.002637000522f, 0.002806699602f,
    -0.001952727907f,-0.002976920689f, 0.001278062933f, 0.003007010324f,-0.0006404390442f,
    -0.002912638476f, 6.25585817e-05f, 0.002713265596f,0.0004381401814f,-0.002430909313f,
    -0.0008498533862f, 0.002088745357f, 0.001166231348f,-0.001709946198f,-0.001386163873f,
     0.001316450187f,  0.00151323271f,-0.0009281134699f,-0.001554950606f,0.0005619520671f,
     0.001521934057f,-0.0002315903112f,-0.001426957548f,-5.294919538e-05f, 0.001284090686f,
    0.0002853082842f,-0.001107754651f,-0.0004626391747f,0.0009119354654f,0.0005853045732f,
    -0.0007095625624f,-0.0006564365467f, 0.000511923281f,0.0006813500659f,-0.000328328344f,
    -0.0006669674767f,0.0001658407709f,0.0006212408189f,-2.920626684e-05f,-0.0005525139859f,
    -7.899478805e-05f,0.0004690969654f,0.0001583035773f,-0.000378635712f,-0.0002099739359f,
    0.0002879940439f,0.0002367390116f,-0.0002027368464f,-0.0002426030405f,0.0001275309332f,
    0.0002318563929f,-6.480750017e-05f,-0.0002115379175f,1.862973113e-05f,0.0001855564915f,
    1.761533349e-05f,-0.0001801491017f,-3.52360621e-05f,0.0002211412939f,0.0003212716547f,
    0.0001223077998f
  };




float value_out1 = 0;
int n_fir = coeff_buf1.size();  //порядок фильтра
QVector<float> delay_line(n_fir);



// параметры фильтра2 6500Гц
const QVector<float> coeff_buf2 = {
    6.21047584e-05f,0.0003430792131f,0.0002771005966f,-9.973538545e-05f,-0.0001311936649f,
   0.0001578978263f, 3.80656129e-05f,-0.0001958950015f,7.263301086e-05f,0.0001843549398f,
   -0.0001911742729f,-0.0001057938862f,0.0002837833308f,-3.806532186e-05f,-0.0003087402147f,
   0.0002194141125f,0.0002331314463f,-0.0003855315736f,-4.995101335e-05f,0.0004710958165f,
   -0.000209787715f,-0.000419264863f,0.0004767143691f,0.0002062851854f,-0.0006575302104f,
   0.0001394564752f,0.0006630945718f,-0.0005330517306f,-0.0004429471446f, 0.000849016069f,
   1.438602249e-05f,-0.0009566021035f, 0.000526296848f,0.0007662610733f,-0.001019022427f,
   -0.000272227684f, 0.001282440149f,-0.0004257310356f,-0.001173969358f, 0.001133988961f,
   0.0006491797976f,-0.001613084576f,0.0002011830802f,  0.00165269943f,-0.001155200298f,
   -0.001151348115f, 0.001911048079f,0.0001733255049f,-0.002176588867f, 0.001041901531f,
    0.001772666466f,-0.002130411798f,-0.0007152273902f, 0.002706723521f,-0.0007557109348f,
   -0.002492512343f, 0.002220343566f, 0.001429448486f,-0.003192535369f,0.0002651723626f,
    0.003274482908f,-0.002129181521f, -0.00230500102f,   0.0035745278f,0.0004492966109f,
   -0.004066887777f, 0.001809591893f,   0.0033127598f,-0.003788372967f,-0.001390977995f,
    0.004804607481f,-0.001224343549f,-0.004404617939f, 0.003770351177f, 0.002543020295f,
   -0.005412995815f,0.0003519529128f, 0.005514387973f,-0.003464058507f,-0.003866587533f,
    0.005813409109f,0.0008080609841f,-0.006561718415f, 0.002826545155f, 0.005300561432f,
   -0.005930540618f,-0.002232860075f, 0.007456179243f,-0.001835289877f,-0.006764805876f,
    0.005698014982f, 0.003873218317f,-0.008104615845f,0.0004922008957f, 0.008161972277f,
   -0.005068638362f,-0.005655044224f, 0.008420027792f, 0.001172706136f, -0.00938704703f,
    0.004017945379f, 0.007482705638f,-0.008327854797f,-0.003099828726f,  0.01033326797f,
   -0.002551524201f,-0.009244623594f,  0.00777567178f, 0.005202608649f, -0.01090205554f,
   0.0007064603851f,  0.01082092989f,-0.006739098113f,-0.007371548563f,  0.01101176534f,
    0.001448128838f, -0.01209270488f, 0.005226756912f, 0.009481253102f, -0.01060615107f,
    -0.00381400669f,  0.01295188628f,-0.003282355843f, -0.01139940601f, 0.009660966694f,
    0.006269552279f, -0.01331086643f,0.0009837807156f,  0.01299692877f, -0.00818823278f,
   -0.008677940816f,    0.013110945f, 0.001561056008f, -0.01415850502f, 0.006237297319f,
       0.010896964f, -0.01232843846f,-0.004220688716f,  0.01479244325f,-0.003893334186f,
    -0.01279028878f,  0.01097856462f, 0.006849942263f, -0.01483879331f, 0.001271694899f,
     0.01423788909f,-0.009115529247f,-0.009300094098f,  0.01427539065f,  0.00148974976f,
    -0.01514617912f,  0.00682959659f,  0.01143071242f, -0.01312014647f,-0.004240615293f,
     0.01545580011f,-0.004240615293f, -0.01312014647f,  0.01143071242f,  0.00682959659f,
    -0.01514617912f,  0.00148974976f,  0.01427539065f,-0.009300094098f,-0.009115529247f,
     0.01423788909f, 0.001271694899f, -0.01483879331f, 0.006849942263f,  0.01097856462f,
    -0.01279028878f,-0.003893334186f,  0.01479244325f,-0.004220688716f, -0.01232843846f,
       0.010896964f, 0.006237297319f, -0.01415850502f, 0.001561056008f,    0.013110945f,
   -0.008677940816f, -0.00818823278f,  0.01299692877f,0.0009837807156f, -0.01331086643f,
    0.006269552279f, 0.009660966694f, -0.01139940601f,-0.003282355843f,  0.01295188628f,
    -0.00381400669f, -0.01060615107f, 0.009481253102f, 0.005226756912f, -0.01209270488f,
    0.001448128838f,  0.01101176534f,-0.007371548563f,-0.006739098113f,  0.01082092989f,
   0.0007064603851f, -0.01090205554f, 0.005202608649f,  0.00777567178f,-0.009244623594f,
   -0.002551524201f,  0.01033326797f,-0.003099828726f,-0.008327854797f, 0.007482705638f,
    0.004017945379f, -0.00938704703f, 0.001172706136f, 0.008420027792f,-0.005655044224f,
   -0.005068638362f, 0.008161972277f,0.0004922008957f,-0.008104615845f, 0.003873218317f,
    0.005698014982f,-0.006764805876f,-0.001835289877f, 0.007456179243f,-0.002232860075f,
   -0.005930540618f, 0.005300561432f, 0.002826545155f,-0.006561718415f,0.0008080609841f,
    0.005813409109f,-0.003866587533f,-0.003464058507f, 0.005514387973f,0.0003519529128f,
   -0.005412995815f, 0.002543020295f, 0.003770351177f,-0.004404617939f,-0.001224343549f,
    0.004804607481f,-0.001390977995f,-0.003788372967f,   0.0033127598f, 0.001809591893f,
   -0.004066887777f,0.0004492966109f,   0.0035745278f, -0.00230500102f,-0.002129181521f,
    0.003274482908f,0.0002651723626f,-0.003192535369f, 0.001429448486f, 0.002220343566f,
   -0.002492512343f,-0.0007557109348f, 0.002706723521f,-0.0007152273902f,-0.002130411798f,
    0.001772666466f, 0.001041901531f,-0.002176588867f,0.0001733255049f, 0.001911048079f,
   -0.001151348115f,-0.001155200298f,  0.00165269943f,0.0002011830802f,-0.001613084576f,
   0.0006491797976f, 0.001133988961f,-0.001173969358f,-0.0004257310356f, 0.001282440149f,
   -0.000272227684f,-0.001019022427f,0.0007662610733f, 0.000526296848f,-0.0009566021035f,
   1.438602249e-05f, 0.000849016069f,-0.0004429471446f,-0.0005330517306f,0.0006630945718f,
   0.0001394564752f,-0.0006575302104f,0.0002062851854f,0.0004767143691f,-0.000419264863f,
   -0.000209787715f,0.0004710958165f,-4.995101335e-05f,-0.0003855315736f,0.0002331314463f,
   0.0002194141125f,-0.0003087402147f,-3.806532186e-05f,0.0002837833308f,-0.0001057938862f,
   -0.0001911742729f,0.0001843549398f,7.263301086e-05f,-0.0001958950015f, 3.80656129e-05f,
   0.0001578978263f,-0.0001311936649f,-9.973538545e-05f,0.0002771005966f,0.0003430792131f,
    6.21047584e-05f
 };


float value_out2 = 0;

QVector <float> Average_buffer(1764);
QVector <float> Average_buffer2(1764);
QVector <float> sum_buffer(441);
QVector <float> sum_buffer2(441);
QVector <float> Eta0 = //{0b01,0b00,0b00,0b01, 0b01,0b00,0b00,0b01, 0b01,0b00,0b00,0b01, 0b01,0b00,0b00,0b01, 0b00,0b01,0b01,0b00, 0,0b01,0b01,0b00, 0b00,0b01,0b01,0b00, 0b00,0b01,0b01,0b00};//25
        {1.0f,1.0f,0.0f,0.0f};//0  {1.0f,1.0f,0.0f,0.0f} {1.0f,0.0f,1.0f,0.0f};
QVector <float> Eta1 = {1.0f,0.0f,1.0f,0.0f};//1
//QVector <int> Eta2 = {0b01,0b00,0b00,0b01};//2

float sum = 0;
float sum2 = 0;
float Average = 0;
float Average2 = 0;
int indFirst_Average;
int indLast_Average = 0;
int indBetween_Average = 441;

const int Average_buffer_size = 1764; //1764
const int Average_buffer2_size = 1764;
const int sum_buffer_size = 441;
const int sum_buffer2_size = 441;
//audio->QAudioInput::periodSize()

int first_i_A;
int last_i_A = 0;
int beetw_is_A;


float C_0;
float C2_0;
float C_fin_0;

float C_1;
float C2_1;
float C_fin_1;

float C_2;
float C2_2;
float C_fin_2;

const float limit0 = 0.01133f; //0.01133f
const float limit1 = 0.0193f;

unsigned char reg = 0b10000000;
unsigned char symbol = 0b00000000;
int ans;
int reg_count = 0;
int timer = 0;
bool first_read = false;


const int f_d1 = 22050;
float fstop1 = 2655.0f;
float tstop1 = 1.0f / fstop1;
float dt1 = 1.0f / f_d1;
float k_lp1 = dt1 / ( dt1 + tstop1 );


const int f_d2 = 22050;
float fstop2 = 1540.0f;
float tstop2 = 1.0f / fstop2;
float dt2 = 1.0f / f_d2;
float k_lp2 = dt2 / ( dt2 + tstop2 );



bool first_take = true;
float value_LPF_C0;
float value_LPF_C1;



float prev_value_LPF_C0;
float prev_value_LPF_C1;





//QIODevice *m_input;

//int main(int argc, char *argv[])
int main ()
{


    // очистка файла
    file.open(QIODevice::WriteOnly | QIODevice::Text);
    file.close();

    //открытие файла для записи
    file.open(QIODevice::WriteOnly | QIODevice::Append | QIODevice::Text);

    //задание параметров устройства приема(поля объекта format класса QAudioFormat)
    format.setSampleRate(22050);//частота дискретизации
    format.setChannelCount(1);//количество каналов записи
    format.setSampleSize(8);//разрядность АЦП
    format.setCodec("audio/pcm");//объявление имени использующего кодека
    format.setByteOrder(QAudioFormat::LittleEndian);//порядок чтения битов буфера(посмотреть в справке аудио формат)
    format.setSampleType(QAudioFormat::UnSignedInt);//объявление типа предсатвления считываемых данных

    //проверка соответствия параметров устройства заданным параметрам
    QAudioDeviceInfo info = QAudioDeviceInfo::defaultInputDevice();//создание объета info класса QAudioDeviceInfo
    if (!info.isFormatSupported(format)) {//если параметры объекта формат не соответствуют фактическим параметрам устройства приема,
    format = info.nearestFormat(format);//то система выберет ближайшие значенния параметров
    }

    //объявляется объект audio класса  QAudioInput обладающий параметрами объектов info и format
    audio = new QAudioInput(info,format);

    //индикатор наличия ошибок в системе(0,1,2 или 3)
    int error = audio->QAudioInput :: error();
    cout << error << endl;

    //индикатор состояния системы(1-5)
    int state = audio->QAudioInput::state ();
    cout << state << endl;

    //блок вывода параметров дооступных для устройства// qDebug() используем для вывода, так как выводим весь набор значений для каждого параметра
    qDebug() << "SupportedByteOrder: " << info.QAudioDeviceInfo::supportedByteOrders();
    qDebug() << "SupportedChannelCounts:" << info.QAudioDeviceInfo::supportedChannelCounts();
    qDebug() << "SupportedSampleTypes:" << info.QAudioDeviceInfo::supportedSampleTypes();
    qDebug() << "SupportedSampleSizes:" << info.QAudioDeviceInfo::supportedSampleSizes();
    qDebug() << "SupportedSampleRates:" << info.QAudioDeviceInfo::supportedSampleRates();

    //объявление значения громкости(уровень чувствительности)
    audio->QAudioInput::setVolume(1.0);

    //активация записи
    input = audio->start();

    //state = audio->QAudioInput::state ();

    // блок записи данных
    char buffer[8820];//создание буфера для записи данных(пустой - нули)
    //int sum = 0;
    int bytes_ready;//переменная хранящая количество доступных для записи байтов
    int i = 0;//преременная счетчика while

    //цикл записи данных(ограничен по времени- 300 раз производится проверка буффера)
    while (i < 600) {
    bytes_ready = audio->bytesReady();//проверка количества доступных для чтения байтов внутри аудиоустройства
    //qDebug() << i << ' ' << audio->bytesReady() << audio->QAudioInput::periodSize();//вывод номера обращения к буферу, вывод доступных для считывания байт, вывод минимального необходимого количества байт для чтения
    if (bytes_ready >= (audio->QAudioInput::periodSize())) {//при наличии доступных для чтения байтов превышающее количество оптимальных для чтения байтов
        input->read(buffer,bytes_ready);//считываем данные записывая в буфер все доступные байты
        for (int j = 0; j < bytes_ready; j++) {//пока счетчик меньше количества доступных для чтения-записи байт(для всех досупных байт)
            //quint8 value = buffer[j];//запись j-того элемента буфера в переменную x с преобразованием типа в беззнаковый
            quint8 value = (qFromLittleEndian<qint8>(buffer[j]));
            //value = qAbs(value - 127);

            //блок обработки данных(фильтры)

            for (int i = 0; i < (n_fir - 1) ; i++ ) // формирование линии задержки, выполнять пока значение i не будет равно значению порядка фильтра
            {
            value_out1 += coeff_buf1[n_fir - (i+1)] * delay_line[i];// умножение мгновенного значения сигнала на коэффициент фильтра1
            value_out2 += coeff_buf2[n_fir - (i+1)] * delay_line[i];// умножение мгновенного значения сигнала на коэффициент фильтра2
            delay_line[i] = delay_line[i+1];// переход к следующему элементу(сдвиг линии задежки)
            }
            value_out1 += coeff_buf1[0] * delay_line[n_fir - 1];// умножение первого коэффициента фильтра1 на последний элемент линии задержки
            value_out2 += coeff_buf2[0] * delay_line[n_fir - 1];// умножение первого коэффициента фильтра2 на последний элемент линии задержки
            delay_line[n_fir - 1] = value;
            //cout<<"check1! "<< value_out1 <<endl;
            //добавление нового мгновенного значения сигнала (байта) в линию задержки
            // *********************************************************

            if (first_take == true)
            {
            value_LPF_C0 = k_lp1 * value_out1;
            value_LPF_C1 = k_lp2 * value_out2;
            first_take = false;
            }
            else
            {
             value_LPF_C0 = prev_value_LPF_C0 * (1 - k_lp1) + value_out1 * k_lp1;
             value_LPF_C1 = prev_value_LPF_C1 * (1 - k_lp2) + value_out2 * k_lp2;//
             prev_value_LPF_C0 = value_LPF_C0;
             prev_value_LPF_C1 = value_LPF_C1;
             }


            //согласованный фильтр

            // функция поиска среднего значения амплитуды в окне 441 отсчет (работает закольцованно)
            if (indLast_Average == sum_buffer_size)// условие обнуляющее индекс вхождения в инию задерки если он савняется с велииной линии задерки(ЛЗ)
            {
             indLast_Average = 0;
            }
            //условие для определения предыдущего элемента линии задержки
            if (indLast_Average >= indBetween_Average) {indFirst_Average = indLast_Average - indBetween_Average;}
            else {indFirst_Average = indLast_Average + (sum_buffer_size - indBetween_Average);}

            sum -= sum_buffer[indFirst_Average];//вычитание предыдущего элемента линии задержки из суммы элементов в ЛЗ(для сигнала отфильтрованного по частоте 5200)
            sum_buffer[indFirst_Average] = value_LPF_C0;//запись в на место прелыдщего значения текущего значения(для сигнала отфильтрованного по частоте 5200)
            sum += sum_buffer[indFirst_Average];//суммирование текущего элемента с ЛЗ(для сигнала отфильтрованного по частоте 5200)

            sum2 -= sum_buffer2[indFirst_Average];//вычитание предыдущего элемента линии задержки из суммы элементов в ЛЗ(для сигнала отфильтрованного по частоте 6500)
            //sum_buffer2[indFirst_Average] = value_out2;
            sum_buffer2[indFirst_Average] = value_LPF_C1;//запись в на место прелыдщего значения текущего значения(для сигнала отфильтрованного по частоте 6500)
            sum2 += sum_buffer2[indFirst_Average];//суммирование текущего элемента с ЛЗ(для сигнала отфильтрованного по частоте 6500)

            Average = sum / sum_buffer_size;//нахождение среднего значения линии здержки(для сигнала отфильтрованного по частоте 5200)
            Average2 = sum2 / sum_buffer2_size;//нахождение среднего значения линии здержки(для сигнала отфильтрованного по частоте 6500)
            indLast_Average++;


// условие обнуляющее индекс вхождения в инию задерки по количеству бит если он савняется с величиной линии задерки(ЛЗ)
            if (last_i_A == Average_buffer_size)
             {
             last_i_A = 0;
             }
//запись текущего среднего значения в ЛЗ
             Average_buffer[last_i_A] = Average;
             Average_buffer2[last_i_A] = Average2;

            //организация линии задержки для 4 бит
             for (int i = 0; i < 4; i++) {
// условие для поиска следующего среднего значения для умножения на соответствующий элемент линии задержки
                 if (i == 0) {beetw_is_A = 0;}
                 else
                 {beetw_is_A =(441 * i) - 1;
             }
             if (last_i_A >= beetw_is_A) {first_i_A = last_i_A - beetw_is_A;}
             else {first_i_A = last_i_A + (Average_buffer_size - beetw_is_A);}
             // умножеие среднего значения для первого и второго сигнала(после f1 и f2) на элемент эталонной последовательности для 0 и суммирование
             C_0 += (Eta0[3 - i] * Average_buffer[first_i_A]);
             C2_0 += (Eta0[3 - i] * Average_buffer2[first_i_A]);
             // умножеие среднего значения для первого и второго сигнала(после f1 и f2) на элемент эталонной последовательности для 1 и суммирование
             C_1 += (Eta1[3 - i] * Average_buffer[first_i_A]);
             C2_1 += (Eta1[3 - i] * Average_buffer2[first_i_A]);
        }
             last_i_A++;
// вычитание значения кореляционной функции одного сигнала из другого для последовательности кодирующей 0
             C_fin_0 = (C2_0-C_0);
             // вычитание значения кореляционной функции одного сигнала из другого для последовательности кодирующей 0
             C_fin_1 = (C2_1-C_1);


             /*if (first_take == true)
             {
             value_LPF_C0 = k_lp * C_fin_0;
             value_LPF_C1 = k_lp * C_fin_1;
             first_take = false;
             }
             else
             {
              value_LPF_C0 = prev_value_LPF_C0 * (1 - k_lp) + C_fin_0 * k_lp;
              value_LPF_C1 = prev_value_LPF_C1 * (1 - k_lp) + C_fin_1 * k_lp;//
              prev_value_LPF_C0 = value_LPF_C0;
              prev_value_LPF_C1 = value_LPF_C1;
              }*/



//реализация порогового устройства
             if (((C_fin_1 >= limit1) || (C_fin_0 >= limit0)) && (first_read == false)) {// при превышении порога активируется счетчик
                 first_read = true;
                 timer = 1763;
                 cout << "start" << endl;
             }
// при срабатывании порогового устройства для 0
             if((C_fin_0 >= limit0) && (timer >= 1763)){
               reg >>= 1;//битовый сдвиг в переменной типа char
               reg_count++;
               cout << "0";
               timer = 0;//обнуление тайммера
             }
// при срабатывании порогового устройства для 1
             if((C_fin_1 >= limit1) && (timer >= 1763)){
               symbol |= reg;//запись 1 в переменную типа char
               reg >>= 1;
               reg_count++;
               cout << "1";
               timer = 0;//обнуление тайммера
             }
//вывод данных в консоль
             if (reg_count == 8)
             {   ans = symbol;//преобразование переменной из типа char в целочсленный тип
                 cout << ' ' << symbol << endl;//вывод символа в консоль
                 symbol = 0;
                 reg = 0b10000000;
                 reg_count = 0;

             }


           //запись данных в текстовый файл
            text_out << value << ' ' << value_out1<< ' '<< value_out2 << ' ' << C_fin_0 << ' ' << C_fin_1 << "\n";//запись значения x в файл txt
            //обнуление необходимых параметров
             C_0 = 0.0f;
             C2_0 = 0.0f;
             C_1 = 0.0f;
             C2_1 = 0.0f;
//счетчик таймера
             if (first_read == true) {
             timer++;
             }



            value_out1 = 0.0f;//обнуляем значение суммы в линии задержки второго фильтра
            value_out2 = 0.0f;


    }
     i ++;//накапливание счетчика while
     //cout<<"check! "<< i <<endl;
    }

    }
    //symbol = 'f';
    //symbol = 0b00100010;
    //cout << symbol << endl;
    audio->stop();//закрытие файла для чтения
    file.close();//закрытие файла txt для прекращения записи данных
    delete audio;//сброс заданных для устройства параметров

    //state = audio->QAudioInput::state ();
    //qDebug() << state;


    return 0;

}
